import{l as c}from"./index-DkBu_uvV.js";const d=new Map;function S(e=null){if(e){const r=d.get(e);r&&(clearTimeout(r),d.delete(e))}else for(const[r,u]of d.entries())clearTimeout(u),d.delete(r)}async function y(e,r){return r.slotId&&!r.isLegacy?e.rpc("pre_join_slot",{p_slot_id:r.slotId}):e.rpc("pre_join_quiz",{p_quiz_id:r.id})}async function h(e,r){return r.slotId&&!r.isLegacy?e.rpc("join_slot",{p_slot_id:r.slotId}):e.rpc("join_quiz",{p_quiz_id:r.id})}async function E({supabase:e,quiz:r,user:u}){const a=(r==null?void 0:r.slotId)||(r==null?void 0:r.id);if(!e||!r||!a)return{status:"error",error:new Error("Missing quiz or supabase client")};if(!u||!u.id)return{status:"error",error:new Error("Not authenticated")};try{const s=String((r==null?void 0:r.status)||"").trim().toLowerCase();if(s==="paused"||s==="stopped"||s==="skipped")return{status:"error",error:new Error("Quiz is paused. Please try later.")};if(r!=null&&r.stop_override)return{status:"error",error:new Error("Quiz is temporarily stopped. Please try later.")}}catch(s){}try{const s=r.start_time?new Date(r.start_time).getTime():null,f=r.end_time?new Date(r.end_time).getTime():null,l=Date.now();if(!s||!f){const{error:o}=await y(e,r);return o?{status:"error",error:o}:{status:"pre_joined"}}const p=5e3,m=l>=s-p&&l<f,g=s-(p+1500);if(l<g){const{error:o}=await y(e,r);return o?{status:"error",error:o}:{status:"pre_joined"}}if(!m&&l>=g&&l<s-300){const{error:o}=await y(e,r);if(o)return{status:"error",error:o};if(!d.has(a)){const i=Math.max(50,s-(p-100)-Date.now()),w=setTimeout(async()=>{d.delete(a);try{const{error:n}=await h(e,r);if(n){const t=String(n.message||"").toLowerCase();if(t.includes("already")||t.includes("completed")){c.debug("Scheduled join: already joined/completed",a);return}if(t.includes("not active")){c.debug("Scheduled join: still not active, giving up this cycle",a);return}c.error("Scheduled join error",n.message||n)}else c.debug("Scheduled join success",a)}catch(n){c.error("Scheduled join throw",(n==null?void 0:n.message)||n)}},i);return d.set(a,w),{status:"scheduled_retry",scheduledAt:Date.now()+i}}return{status:"scheduled_retry",scheduledAt:null}}if(m){const{error:o}=await h(e,r);if(!o)return{status:"joined"};const i=String(o.message||"").toLowerCase();if(i.includes("already")||i.includes("completed"))return{status:"already"};if(i.includes("not active")){if(!d.has(a)){const n=setTimeout(async()=>{d.delete(a);try{const{error:t}=await h(e,r);t&&!String(t.message||"").toLowerCase().includes("already")&&c.error("Final join retry failed",t.message||t)}catch(t){c.error("Final join retry throw",(t==null?void 0:t.message)||t)}},600);return d.set(a,n),{status:"scheduled_retry",scheduledAt:Date.now()+600}}return{status:"scheduled_retry",scheduledAt:null}}return{status:"error",error:o}}const{error:_}=await y(e,r);return _?{status:"error",error:_}:{status:"pre_joined"}}catch(s){return{status:"error",error:s}}}export{S as c,E as s};
