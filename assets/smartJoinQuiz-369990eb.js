import{l as d}from"./index-f0cac36e.js";const i=new Map;async function u(e,r){return r.slotId&&!r.isLegacy?e.rpc("pre_join_slot",{p_slot_id:r.slotId}):e.rpc("pre_join_quiz",{p_quiz_id:r.id})}async function p(e,r){return r.slotId&&!r.isLegacy?e.rpc("join_slot",{p_slot_id:r.slotId}):e.rpc("join_quiz",{p_quiz_id:r.id})}async function E({supabase:e,quiz:r,user:h}){const a=(r==null?void 0:r.slotId)||(r==null?void 0:r.id);if(!e||!r||!a)return{status:"error",error:new Error("Missing quiz or supabase client")};if(!h||!h.id)return{status:"error",error:new Error("Not authenticated")};try{const s=String((r==null?void 0:r.status)||"").trim().toLowerCase();if(s==="paused"||s==="stopped"||s==="skipped")return{status:"error",error:new Error("Quiz is paused. Please try later.")};if(r!=null&&r.stop_override)return{status:"error",error:new Error("Quiz is temporarily stopped. Please try later.")}}catch(s){}try{const s=r.start_time?new Date(r.start_time).getTime():null,y=r.end_time?new Date(r.end_time).getTime():null,l=Date.now();if(!s||!y){const{error:o}=await u(e,r);return o?{status:"error",error:o}:{status:"pre_joined"}}const f=5e3,g=l>=s-f&&l<y,m=s-(f+1500);if(l<m){const{error:o}=await u(e,r);return o?{status:"error",error:o}:{status:"pre_joined"}}if(!g&&l>=m&&l<s-300){const{error:o}=await u(e,r);if(o)return{status:"error",error:o};if(!i.has(a)){const c=Math.max(50,s-(f-100)-Date.now()),w=setTimeout(async()=>{i.delete(a);try{const{error:n}=await p(e,r);if(n){const t=String(n.message||"").toLowerCase();if(t.includes("already")||t.includes("completed")){d.debug("Scheduled join: already joined/completed",a);return}if(t.includes("not active")){d.debug("Scheduled join: still not active, giving up this cycle",a);return}d.error("Scheduled join error",n.message||n)}else d.debug("Scheduled join success",a)}catch(n){d.error("Scheduled join throw",(n==null?void 0:n.message)||n)}},c);return i.set(a,w),{status:"scheduled_retry",scheduledAt:Date.now()+c}}return{status:"scheduled_retry",scheduledAt:null}}if(g){const{error:o}=await p(e,r);if(!o)return{status:"joined"};const c=String(o.message||"").toLowerCase();if(c.includes("already")||c.includes("completed"))return{status:"already"};if(c.includes("not active")){if(!i.has(a)){const n=setTimeout(async()=>{i.delete(a);try{const{error:t}=await p(e,r);t&&!String(t.message||"").toLowerCase().includes("already")&&d.error("Final join retry failed",t.message||t)}catch(t){d.error("Final join retry throw",(t==null?void 0:t.message)||t)}},600);return i.set(a,n),{status:"scheduled_retry",scheduledAt:Date.now()+600}}return{status:"scheduled_retry",scheduledAt:null}}return{status:"error",error:o}}const{error:_}=await u(e,r);return _?{status:"error",error:_}:{status:"pre_joined"}}catch(s){return{status:"error",error:s}}}export{E as s};
